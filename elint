#!/usr/bin/env bash

# https://github.com/koalaman/shellcheck/issues/667
# shellcheck disable=SC2103
# shellcheck source=/dev/null

# Set options.
set -e
set -o pipefail
shopt -s nullglob
shopt -s dotglob

# Parse command-line arguments.
tasks=("$@")

# Abort if no tasks given.
if (( $# == 0 )); then
    echo "usage: elint <task>..." 1>&2
    exit 1
fi

# Determine the directory containing the elint source code.
elint="$(cd "$(dirname "$0")" && pwd)"

# Locate the dispatch file.
dispatch=$PWD/elint-config/dispatch

# Abort if the dispatch file does not exist.
if [[ ! -f $dispatch ]]; then
    if [[ -d $dispatch ]]; then
        echo "elint: $dispatch: Is a directory" 1>&2
    elif [[ -L $dispatch ]]; then
        echo "elint: $dispatch: Broken symlink" 1>&2
    else
        echo "elint: $dispatch: No such file or directory" 1>&2
    fi
    exit 1
fi

# Define functions that can be called from the dispatch file.
task() {
    if [[ $task == "$1" ]]; then
        if [[ -n $found_match ]]; then
            echo "elint: $task: Multiple definitions" 1>&2
            exit 1
        fi
        found_match=yes
        checker=$1
        shift
        args=("$@")
    fi
}

custom_task() {
    if [[ $task == "$1" ]]; then
        if [[ -n $found_match ]]; then
            echo "elint: $task: Multiple definitions" 1>&2
            exit 1
        fi
        found_match=yes
        checker=$2
        shift 2
        args=("$@")
    fi
}

group() {
    if [[ $task == "$1" ]]; then
        if [[ -n $found_match ]]; then
            echo "elint: $task: Multiple definitions" 1>&2
            exit 1
        fi
        found_match=yes
        group=yes
        shift
        args=("$@")
    fi
}

# Define a recursive function to run a task.
run_task() {

    # This function takes one argument, the task name. It has to be
    # assigned to $task so that the functions called from the dispatch
    # file can use the value.
    task=$1

    # Reset variables that are set by functions that may be called in
    # the dispatch file.
    found_match=
    checker=
    group=
    args=()

    # Load the dispatch file.
    IFS= source "$dispatch"

    # If no match was found, then $found_match will not be set. Abort.
    if [[ -z $found_match ]]; then
        echo "elint: $task: No such task" 1>&2
        exit 1
    fi

    # Check if the matched task was a task group or a regular task.
    if [[ -n $group ]]; then
        for subtask in "${args[@]}"; do
            run_task "$subtask"
        done
    else
        collected_args=()
        collecting_args=yes

        file_specified=

        for arg in "${args[@]}"; do
            if [[ -n $collecting_args ]]; then
                if [[ $arg == -- ]]; then
                    collecting_args=
                    continue

                elif [[ $arg == -* ]]; then
                    collected_args+=($arg)
                    continue
                fi
            fi

            args_str=""
            for collected_arg in "${collected_args[@]}"; do
                args_str="$args_str $collected_arg"
            done

            IFS= expanded_files=($arg)
            if [[ ${#expanded_files[@]} -eq 0 ]]; then
                echo "elint: $arg: No matches found" 1>&2

                if [[ -n $output ]]; then
                    if [[ $task == "$checker" ]]; then
                        echo "==> elint: $task$args_str: $file"
                    else
                        echo "==> elint: $task: $checker$args_str: $file"
                    fi
                    echo "$output"
                    fail=yes
                fi
            fi

            for file in "${expanded_files[@]}"; do
                output=$("$elint/elint-file" "$checker" "$file" \
                                             "${collected_args[@]}")

                if [[ -n $output ]]; then
                    if [[ $task == "$checker" ]]; then
                        echo "==> elint: $task$args_str: $file"
                    else
                        echo "==> elint: $task: $checker$args_str: $file"
                    fi
                    echo "$output"
                    fail=yes
                fi
            done

            collected_args=()
            collecting_args=yes
            file_specified=yes
        done

        if [[ -z $file_specified ]]; then
            output=$("$elint/elint-file" "$checker" "" "${collected_args[@]}")

            if [[ -n $output ]]; then
                if [[ $task == "$checker" ]]; then
                    echo "==> elint: $task$args_str: $file"
                else
                    echo "==> elint: $task: $checker$args_str: $file"
                fi
                echo "$output"
                fail=yes
            fi
        fi
    fi
}

# Initialize a variable to keep track of the final exit code.
fail=

# Run all the tasks.
for task in "${tasks[@]}"; do
    run_task "$task"
done

# Terminate with the appropriate exit code.
if [[ -n $fail ]]; then
    exit 1
fi
